<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Веб-рогалик — craft & AI enemies</title>
<style>
:root{ --ui-bg: rgba(0,0,0,0.78); --btn:#111; --btn-border:#fff; }
body{ margin:0; background:#000; color:#fff; font-family:monospace; overflow:hidden; }
#gameWrap{ position:relative; width:100vw; height:100vh; }
canvas{ display:block; background:#000; image-rendering: pixelated; }
#ui{ position:absolute; right:10px; top:10px; background:var(--ui-bg); padding:10px; border:1px solid #444; width:320px; font-size:14px; line-height:1.3; }
#invContent{ max-height:38vh; overflow:auto; margin-top:6px; white-space:pre-wrap; }
#controls{ margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
button, select { background:var(--btn); color:#fff; border:1px solid var(--btn-border); padding:6px 8px; cursor:pointer; }
.small{ padding:4px 6px; font-size:13px; }
.hint{ font-size:12px; color:#bbb; margin-top:6px; }
.modal{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.95); border:1px solid #666; padding:12px; z-index:50; max-width:90vw; max-height:90vh; overflow:auto; }
.row{ display:flex; gap:8px; align-items:center; }
.recipe { border:1px solid #333; padding:8px; margin:6px 0; }
.small-muted{ color:#aaa; font-size:12px; }
.input-inline{ display:inline-block; margin-left:6px; }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game"></canvas>

  <div id="ui">
    <div>Уровень: <b id="level">1</b> &nbsp; HP: <b id="hp">100</b></div>
    <div style="margin-top:6px"><b>Инвентарь:</b></div>
    <div id="invContent">Пусто</div>

    <div id="controls">
      <button id="btnUpload" class="small">Загрузить спрайт</button>
      <button id="btnCraftOpen" class="small">Крафт</button>
      <button id="btnUse" class="small">Использовать (X)</button>
      <select id="tileSizeSelect" class="small" title="Размер клетки">
        <option value="24">Клетка 24</option>
        <option value="32" selected>Клетка 32</option>
        <option value="40">Клетка 40</option>
      </select>
    </div>

    <div id="spriteControls">
      <select id="spriteTypeSelect" class="small" title="Тип спрайта">
         <option value="player">Игрок</option>
         <option value="monster_chaser">Враг (Chaser)</option>
         <option value="monster_jumper">Враг (Jumper)</option>
         <option value="monster_wanderer">Враг (Wanderer)</option>
         <option value="monster_ranged">Враг (Ranged)</option>
         <option value="wall">Стена</option>
         <option value="chest">Сундук</option>
         <option value="floor">Пол</option>
      </select>
    </div>

    <div class="hint">Управление: стрелки — ход, Z — атака (соседние), X — использовать зелье.</div>
  </div>
</div>

<input id="fileInput" type="file" accept="image/*" style="display:none" />

<div id="craftModal" class="modal" style="display:none">
  <h3>Крафт — рецепты</h3>
  <div id="recipesList"></div>
  <div style="margin-top:10px"><button id="craftClose" class="small">Закрыть</button></div>
</div>

<script>
let canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
let TILE = 32, MAP_W = 50, MAP_H = 50, VIEW = 7;
let mapState, player, levelNum;
let images = { player:null, wall:null, chest:null, floor:null, monster_chaser:null, monster_jumper:null, monster_wanderer:null, monster_ranged:null };
let fileInput = document.getElementById('fileInput');

const hpEl = document.getElementById('hp');
const invEl = document.getElementById('invContent');
const levelEl = document.getElementById('level');
const btnUpload = document.getElementById('btnUpload');
const btnUse = document.getElementById('btnUse');
const tileSizeSelect = document.getElementById('tileSizeSelect');
const btnCraftOpen = document.getElementById('btnCraftOpen');
const craftModal = document.getElementById('craftModal');
const recipesList = document.getElementById('recipesList');
const craftClose = document.getElementById('craftClose');
const spriteTypeSelect = document.getElementById('spriteTypeSelect');

// Рецепты
const RECIPES = {
  'Супер-Зелье': { requires: {'Зелье среднее':1, 'Кристалл':1}, description: 'Восстанавливает много HP' },
  'Зелье среднее': { requires: {'Зелье малое':2}, description: 'Среднее зелье (из 2 малых).' },
  'Кристалл': { requires: {'Монета':3}, description: 'Собери 3 монеты → кристалл.' },
  'Зелье большое': { requires: {'Зелье среднее':1, 'Кристалл':1}, description: 'Большое зелье.' }
};

function randInt(min,max){ return Math.floor(Math.random()*(max-min+1)) + min; }

function resizeCanvas(){
  const vw = window.innerWidth, vh = window.innerHeight;
  const cols = Math.floor(vw / TILE), rows = Math.floor(vh / TILE);
  canvas.width = cols * TILE;
  canvas.height = rows * TILE;
  VIEW = Math.max(3, Math.min(12, Math.floor(Math.min(cols, rows)/2) - 1));
  draw();
}
window.addEventListener('resize', resizeCanvas);

function generateMap(lv=1){
  const map = [];
  for(let y=0;y<MAP_H;y++){
    const row = [];
    for(let x=0;x<MAP_W;x++){
      row.push((x===0||y===0||x===MAP_W-1||y===MAP_H-1) ? '#' : (Math.random()<0.18 ? '#' : '.'));
    }
    map.push(row);
  }
  map[1][Math.floor(MAP_W/2)] = '>';
  map[MAP_H-2][Math.floor(MAP_W/2)] = '<';

  const lootNames = ['Зелье малое','Зелье среднее','Зелье большое','Монета','Кристалл'];
  const items = [], chests = [], monsters = [];
  const TYPES = ['chaser','jumper','wanderer','ranged'];

  for(let i=0;i<10+lv*2;i++){
    let ix,iy; do { ix = randInt(1,MAP_W-2); iy = randInt(1,MAP_H-2); } while(map[iy][ix] !== '.');
    items.push({x:ix,y:iy,type:lootNames[randInt(0,lootNames.length-1)]});
  }
  for(let i=0;i<3;i++){
    let cx,cy; do { cx = randInt(1,MAP_W-2); cy = randInt(1,MAP_H-2); } while(map[cy][cx] !== '.');
    chests.push({x:cx,y:cy,content:[lootNames[randInt(0,lootNames.length-1)], lootNames[randInt(0,lootNames.length-1)]]});
  }
  for(let i=0;i<5+lv;i++){
    let mx,my; do { mx = randInt(1,MAP_W-2); my = randInt(1,MAP_H-2); } while(map[my][mx] !== '.');
    monsters.push({x:mx,y:my,hp:5+lv*randInt(1,2), dmg:1+Math.floor(lv/1), type:TYPES[randInt(0,TYPES.length-1)], cooldown:0});
  }

  return { map, items, chests, monsters };
}

function init(){
  levelNum = 1;
  mapState = generateMap(levelNum);
  player = { x: Math.floor(MAP_W/2), y: Math.floor(MAP_H/2), hp: 100, inv: [] };
  resizeCanvas(); updateUI(); draw();
}
init();

function drawTileByType(type, px, py){
  if(type === '#'){
    if(images.wall && images.wall.complete) ctx.drawImage(images.wall, px, py, TILE, TILE);
    else { ctx.fillStyle = '#666'; ctx.fillRect(px, py, TILE, TILE); }
  } else if(type === '.' ){
    if(images.floor && images.floor.complete) ctx.drawImage(images.floor, px, py, TILE, TILE);
    else { ctx.fillStyle = '#111'; ctx.fillRect(px, py, TILE, TILE); }
  } else if(type === '>'){ ctx.fillStyle = 'green'; ctx.fillRect(px, py, TILE, TILE);
  } else if(type === '<'){ ctx.fillStyle = 'red'; ctx.fillRect(px, py, TILE, TILE);
  } else { ctx.fillStyle = '#111'; ctx.fillRect(px, py, TILE, TILE); }
}

function drawMonster(m, px, py){
  let imgKey = 'monster_' + m.type;
  if(images[imgKey] && images[imgKey].complete){
    ctx.drawImage(images[imgKey], px, py, TILE, TILE);
  } else {
    const col = m.type==='chaser'?'#8A2BE2':m.type==='jumper'?'#FF4500':m.type==='wanderer'?'#9ACD32':'#1E90FF';
    ctx.fillStyle = col; ctx.fillRect(px, py, TILE, TILE);
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cols = canvas.width / TILE, rows = canvas.height / TILE;
  const halfCols = Math.floor(cols/2), halfRows = Math.floor(rows/2);
  const camX = player.x - halfCols, camY = player.y - halfRows;

  for(let row=0; row<rows; row++){
    for(let col=0; col<cols; col++){
      const gx = col + camX, gy = row + camY;
      const px = col*TILE, py = row*TILE;
      if(gx>=0 && gy>=0 && gx<MAP_W && gy<MAP_H) drawTileByType(mapState.map[gy][gx], px, py);
      else { ctx.fillStyle='#000'; ctx.fillRect(px, py, TILE, TILE); }
    }
  }

  mapState.items.forEach(it=>{
    const ix = it.x - camX, iy = it.y - camY;
    if(ix>=0 && iy>=0 && ix<cols && iy<rows){ ctx.fillStyle='orange'; ctx.fillRect(ix*TILE+TILE*0.2, iy*TILE+TILE*0.2, TILE*0.6, TILE*0.6); }
  });

  mapState.chests.forEach(c=>{
    const cx = c.x - camX, cy = c.y - camY;
    if(cx>=0 && cy>=0 && cx<cols && cy<rows){
      if(images.chest && images.chest.complete) ctx.drawImage(images.chest, cx*TILE, cy*TILE, TILE, TILE);
      else { ctx.fillStyle='blue'; ctx.fillRect(cx*TILE, cy*TILE, TILE, TILE); }
    }
  });

  mapState.monsters.forEach(m=>{
    const mx = m.x - camX, my = m.y - camY;
    if(mx>=0 && my>=0 && mx<cols && my<rows) drawMonster(m, mx*TILE, my*TILE);
  });

  const playerScreenX = halfCols*TILE, playerScreenY = halfRows*TILE;
  if(images.player && images.player.complete) ctx.drawImage(images.player, playerScreenX, playerScreenY, TILE, TILE);
  else { ctx.fillStyle='yellow'; ctx.fillRect(playerScreenX, playerScreenY, TILE, TILE); }
}

function canMove(x,y){ return x>=0 && y>=0 && x<MAP_W && y<MAP_H && mapState.map[y][x]!=='#'; }
function inBounds(x,y){ return x>=0 && y>=0 && x<MAP_W && y<MAP_H; }
function occupiedByMonster(x,y){ return mapState.monsters.some(m=>m.x===x && m.y===y); }

function moveMonsters(){
  for(let m of mapState.monsters){
    if(m.cooldown && m.cooldown>0) m.cooldown--;
    const dist = Math.abs(m.x-player.x)+Math.abs(m.y-player.y);
    if(m.type==='chaser'){ if(dist===1){ player.hp-=m.dmg; continue; }
      const nx=m.x+Math.sign(player.x-m.x), ny=m.y+Math.sign(player.y-m.y);
      if(canMove(nx,ny) && !occupiedByMonster(nx,ny) && !(nx===player.x&&ny===player.y)){ m.x=nx; m.y=ny; }
    } else if(m.type==='jumper'){ if(dist===1){ player.hp-=m.dmg; continue; }
      const dx=Math.sign(player.x-m.x), dy=Math.sign(player.y-m.y);
      const jumpX=m.x+dx*2, jumpY=m.y+dy*2, midX=m.x+dx, midY=m.y+dy;
      if(dx!==0||dy!==0){
        if(inBounds(jumpX,jumpY)&&canMove(jumpX,jumpY)&&!occupiedByMonster(jumpX,jumpY)&&!(jumpX===player.x&&jumpY===player.y)&&canMove(midX,midY)){ m.x=jumpX; m.y=jumpY; }
        else { const nx=m.x+dx, ny=m.y+dy; if(canMove(nx,ny)&&!occupiedByMonster(nx,ny)&&!(nx===player.x&&ny===player.y)){ m.x=nx; m.y=ny; } }
      }
    } else if(m.type==='wanderer'){
      if(Math.random()<0.6){ const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; const [dx,dy]=dirs[randInt(0,dirs.length-1)]; const nx=m.x+dx, ny=m.y+dy; if(canMove(nx,ny)&&!occupiedByMonster(nx,ny)&&!(nx===player.x&&ny===player.y)){ m.x=nx; m.y=ny; } }
      else { const nx=m.x+Math.sign(player.x-m.x), ny=m.y+Math.sign(player.y-m.y); if(canMove(nx,ny)&&!occupiedByMonster(nx,ny)&&!(nx===player.x&&ny===player.y)){ m.x=nx; m.y=ny; } }
      if(Math.abs(m.x-player.x)+Math.abs(m.y-player.y)===1) player.hp-=m.dmg;
    } else if(m.type==='ranged'){
      if(dist<=2){ player.hp-=m.dmg; }
      else if(dist<=6){ if(!m.cooldown){ player.hp-=m.dmg; m.cooldown=2; } }
      else { const nx=m.x+Math.sign(player.x-m.x), ny=m.y+Math.sign(player.y-m.y); if(canMove(nx,ny)&&!occupiedByMonster(nx,ny)&&!(nx===player.x&&ny===player.y)){ m.x=nx; m.y=ny; } }
    }
  }
}

function collectAtPlayer(){
  for(let i=mapState.items.length-1;i>=0;i--){ const it=mapState.items[i]; if(it.x===player.x && it.y===player.y){ player.inv.push(it.type); mapState.items.splice(i,1); } }
  for(let i=mapState.chests.length-1;i>=0;i--){ const c=mapState.chests[i]; if(c.x===player.x && c.y===player.y){ c.content.forEach(v=>player.inv.push(v)); mapState.chests.splice(i,1); } }
}

function playerStep(dx,dy){
  const nx=player.x+dx, ny=player.y+dy; if(!inBounds(nx,ny)) return; if(!canMove(nx,ny)) return; if(occupiedByMonster(nx,ny)) return;
  player.x=nx; player.y=ny; moveMonsters(); collectAtPlayer();
  const tile=mapState.map[player.y][player.x];
  if(tile==='>'){ levelNum++; mapState=generateMap(levelNum); player.x=Math.floor(MAP_W/2); player.y=1; }
  if(tile==='<'){ levelNum=Math.max(1,levelNum-1); mapState=generateMap(levelNum); player.x=Math.floor(MAP_W/2); player.y=MAP_H-2; }
  if(player.hp<=0){ alert('Вы погибли. Рестарт уровня.'); player.hp=100; player.inv=[]; mapState=generateMap(levelNum); player.x=Math.floor(MAP_W/2); player.y=Math.floor(MAP_H/2); }
  updateUI(); draw();
}

function attack(){
  for(let i=mapState.monsters.length-1;i>=0;i--){ const m=mapState.monsters[i]; if(Math.abs(m.x-player.x)+Math.abs(m.y-player.y)===1){ m.hp-=5; if(m.hp<=0) mapState.monsters.splice(i,1); } }
  moveMonsters(); if(player.hp<=0){ alert('Вы погибли'); player.hp=100; player.inv=[]; mapState=generateMap(levelNum); player.x=Math.floor(MAP_W/2); player.y=Math.floor(MAP_H/2); }
  updateUI(); draw();
}

function usePotion(){
  if(player.inv.length===0) return;
  const potIndex=player.inv.findIndex(i=>i.includes('Зелье'));
  if(potIndex===-1) return;
  const name = player.inv[potIndex];
  const healMap = {'Зелье малое':20,'Зелье среднее':50,'Зелье большое':100,'Супер-Зелье':150};
  player.hp = Math.min(100, player.hp + (healMap[name]||0));
  player.inv.splice(potIndex,1);
  updateUI(); draw();
}

function updateUI(){
  hpEl.textContent = player.hp;
  levelEl.textContent = levelNum;
  invEl.textContent = player.inv.length? player.inv.join(', '):'Пусто';
}

// Управление
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowUp') playerStep(0,-1);
  else if(e.key==='ArrowDown') playerStep(0,1);
  else if(e.key==='ArrowLeft') playerStep(-1,0);
  else if(e.key==='ArrowRight') playerStep(1,0);
  else if(e.key.toLowerCase()==='z') attack();
  else if(e.key.toLowerCase()==='x') usePotion();
});

// Крафт
btnCraftOpen.onclick = ()=>{ renderRecipes(); craftModal.style.display='block'; }
craftClose.onclick = ()=>{ craftModal.style.display='none'; }
function renderRecipes(){
  recipesList.innerHTML='';
  for(const key in RECIPES){
    const r=RECIPES[key];
    const div=document.createElement('div'); div.className='recipe';
    div.innerHTML=`<b>${key}</b> — ${r.description} <br><span class="small-muted">Требуется: ${Object.entries(r.requires).map(([k,v])=>v+'x '+k).join(', ')}</span>`;
    const btn=document.createElement('button'); btn.textContent='Сотворить'; btn.className='small';
    btn.onclick=()=>{ attemptCraft(key); };
    div.appendChild(document.createElement('br')); div.appendChild(btn);
    recipesList.appendChild(div);
  }
}

function attemptCraft(name){
  const r=RECIPES[name]; if(!r) return;
  for(const [k,v] of Object.entries(r.requires)){
    const count=player.inv.filter(i=>i===k).length;
    if(count<v){ alert('Недостаточно ингредиентов'); return; }
  }
  // Удаляем ингредиенты
  for(const [k,v] of Object.entries(r.requires)){
    for(let i=0;i<v;i++){ const idx=player.inv.indexOf(k); if(idx>=0) player.inv.splice(idx,1); }
  }
  player.inv.push(name);
  updateUI(); draw();
  alert(name+' создано!');
}

// Загрузка спрайта
btnUpload.onclick = ()=>{ fileInput.click(); }
fileInput.onchange = (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const img = new Image(); img.src=ev.target.result;
    img.onload = ()=>{ images[spriteTypeSelect.value]=img; draw(); }
  };
  reader.readAsDataURL(file);
}

// Изменение размера клетки
tileSizeSelect.addEventListener('change', e=>{
  TILE=parseInt(e.target.value)||32;
  resizeCanvas();
});

</script>
</body>
</html>
